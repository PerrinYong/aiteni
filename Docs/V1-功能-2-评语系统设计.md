我先给你一个**结果结构设计 + 模板句子**，再给一份**伪代码/JS 逻辑**，你可以直接塞进小程序里用。

---

## 一、结果结构（推荐）

最终评估结果可以长这样：

```jsonc
{
  "totalLevel": 3.6,          // 期望值
  "roundedLevel": 3.5,        // 四舍五入后的展示值
  "levelLabel": "发展中业余选手",
  "dimensionScores": {
    "baseline_rally": 3.4,
    "forehand": 3.8,
    "backhand": 3.1,
    "serve": 3.0,
    "return": 3.2,
    "net": 2.7,
    "footwork": 3.5,
    "tactics": 3.3,
    "doubles": 3.0,
    "training": 3.2
  },
  "dimensionComments": {
    "forehand": "正手已经是你的强项之一，在中速多拍中有一定压制力，可以进一步练习不同落点和节奏变化，把优势放大。",
    "backhand": "反手在中速球上已经基本可靠，但遇到高球和快球时容易吃力，建议增加跑动反手和被动防守时的专项练习。",
    "...": "..."
  },
  "summaryText": "..."   // 最终组合好的长评语
}
```

---

## 二、按维度生成细分评语——模板思路

### 1. 每个维度一句「标题 + 细评」

建议统一格式（方便 UI 展示）：

```text
【维度名称（约 X.X 级）】
维度评语句子
```

例如：

```text
【正手（约 3.8 级）】
正手已经是你的强项之一，在中速多拍中有一定压制力，可以进一步练习不同落点和节奏变化，把优势放大。
```

### 2. 维度评语逻辑（用分段 + 模板）

你已经在 JSON 里配置了一些 `suggestion_rules`，
可以按「score 所在区间」选一句基础评语，然后再套一点“强/弱/中性”的补充语。

建议对每个维度设 3 档：

* 低：`score < totalLevel - 0.5` 或 `score < 2.8`
* 中：`totalLevel - 0.5 <= score <= totalLevel + 0.5`
* 高：`score > totalLevel + 0.5` 或 `score >= 3.8`

（totalLevel 用 roundedLevel 或期望值都可以）

**通用补充模板：**

* 高于整体水平（优势维度）：

  ```text
  你在这一项上明显高于整体水平，可以把它当成比赛中的主要得分手段之一。
  ```

* 低于整体水平（短板维度）：

  ```text
  这一项相对是短板，会在比赛中拖慢整体上限，建议作为近期重点练习方向。
  ```

* 接近整体水平（中性维度）：

  ```text
  这一项与整体水平大体一致，可以在保持稳定的基础上，循序渐进地提高质量。
  ```

**合并方式示例（按维度）：**

> 维度基础评语（来自 suggestion_rules） + 优/劣/中补充评语

```text
【发球（约 3.0 级）】
发球已经能承担“开始一分”的任务，可以逐步区分一发和二发，在保证二发稳定的前提下提高一发威胁。
这一项相对是短板，会在比赛中拖慢整体上限，建议作为近期重点练习方向。
```

---

## 三、组合成最终评语的总模板

可以分三块：

1. 总体概述（总等级 + 风格）
2. 优势总结（列 2–3 个维度）
3. 提升重点（列 2–3 个维度）
4. 详细拆解（每个维度一小段）

### 1）总体概述模板

```text
整体来看，你当前的综合水平约为 NTRP {roundedLevel}（{levelLabel}）。

在这个级别上，你已经具备：
- 能与同水平球友进行 {简短描述，如“稳定的中速多拍对抗”/“一定的进攻与防守转换”}；
- 在 {1–2 个核心维度，如“正手和步伐”} 上具备比较清晰的优势；
- 同时在 {1–2 个短板维度，如“发球和网前”} 上还有比较明显的提升空间。
```

`levelLabel` 可以用简单映射表，例如：

```text
1.0–1.5  初学者
2.0–2.5  入门级爱好者
3.0–3.5  发展中业余选手
4.0–4.5  城市级业余高手
5.0–5.5  准专业 / 专业水平
6.0+     职业/国际级
```

### 2）优势总结模板

先从 `dimensionScores` 里，选出 **得分最高的 2–3 项**：

```text
你的主要优势在：
- {维度A名称}（约 {scoreA} 级）：{该维度评语中偏正面的部分}
- {维度B名称}（约 {scoreB} 级）：{同上}
{可选：如果还有明显第三项优势，也可以列出来}
```

为了避免太长，你可以在优势部分只截取维度评语的第一句，或者专门写一句更短的“标签”。

### 3）短板 / 提升重点模板

从 `dimensionScores` 中选出 **得分最低的 2–3 项**：

```text
当前最值得优先提升的环节是：
- {维度X名称}（约 {scoreX} 级）：{该维度评语中偏“建议/改进”的部分}
- {维度Y名称}（约 {scoreY} 级）：{同上}
如果你只想抓重点，建议优先在这两个方向投入练习时间。
```

### 4）详细拆解模板

把之前“一维度一段”的东西整体加在结尾：

```text
下面是各个维度的具体评估与建议：

【底线相持（约 {baseline_rally_score} 级）】
{baseline_rally_comment}

【正手（约 {forehand_score} 级）】
{forehand_comment}

【反手（约 {backhand_score} 级）】
{backhand_comment}

【发球（约 {serve_score} 级）】
{serve_comment}

【接发球（约 {return_score} 级）】
{return_comment}

【网前与高压（约 {net_score} 级）】
{net_comment}

【步伐与场地覆盖（约 {footwork_score} 级）】
{footwork_comment}

【战术与心理（约 {tactics_score} 级）】
{tactics_comment}

【双打意识（约 {doubles_score} 级）】
{doubles_comment}

【训练背景与频率（约 {training_score} 级）】
{training_comment}
```

---

## 四、伪代码 / JS 逻辑示例

### 1）按维度算分

```js
function computeDimensionScores(config, answers) {
  // answers: { questionId: optionId }
  const dimScoreSum = {};
  const dimWeightSum = {};

  for (const q of config.questions) {
    const optId = answers[q.id];
    if (!optId) continue;
    const opt = q.options.find(o => o.id === optId);
    if (!opt) continue;

    const dim = q.dimension;
    const w = q.weight || 1.0;
    const center = opt.center_level;

    if (!dimScoreSum[dim]) {
      dimScoreSum[dim] = 0;
      dimWeightSum[dim] = 0;
    }
    dimScoreSum[dim] += center * w;
    dimWeightSum[dim] += w;
  }

  const dimScores = {};
  for (const dim of Object.keys(dimScoreSum)) {
    dimScores[dim] = dimScoreSum[dim] / dimWeightSum[dim];
  }
  return dimScores;
}
```

### 2）根据 `suggestion_rules` 选维度基础评语

（你在 JSON 里的 `output.suggestion_rules.dimensions` 就是这个）

```js
function pickDimensionComment(config, dimScores, totalLevel) {
  const commentMap = {};

  const rules = config.output.suggestion_rules.dimensions || [];
  for (const rule of rules) {
    const dim = rule.dimension;
    const score = dimScores[dim];
    if (!score) continue;

    // 1. 选区间文案
    let baseText = "";
    for (const range of rule.ranges) {
      const min = range.min ?? -Infinity;
      const max = range.max ?? Infinity;
      if (score >= min && score < max) {
        baseText = range.text;
        break;
      }
    }

    // 2. 根据与总等级的差异，添加补充语
    let extra = "";
    if (score >= totalLevel + 0.5) {
      extra = "你在这一项上明显高于整体水平，可以把它当成比赛中的主要得分手段之一。";
    } else if (score <= totalLevel - 0.5) {
      extra = "这一项相对是短板，会在比赛中拖慢整体上限，建议作为近期重点练习方向。";
    } else {
      extra = "这一项与整体水平大体一致，可以在保持稳定的基础上，循序渐进地提高质量。";
    }

    commentMap[dim] = baseText + extra;
  }

  return commentMap;
}
```

### 3）组合最终 summaryText

```js
function buildSummaryText(config, roundedLevel, totalLevel, dimScores, dimComments) {
  // 1. levelLabel
  let levelLabel = "";
  if (roundedLevel <= 1.5) levelLabel = "初学者";
  else if (roundedLevel <= 2.5) levelLabel = "入门级爱好者";
  else if (roundedLevel <= 3.5) levelLabel = "发展中业余选手";
  else if (roundedLevel <= 4.5) levelLabel = "城市级业余高手";
  else if (roundedLevel <= 5.5) levelLabel = "准专业 / 专业水平";
  else levelLabel = "职业 / 国际级水平";

  // 2. 找优势/短板维度
  const dimList = Object.keys(dimScores).map(dim => ({
    dim,
    score: dimScores[dim]
  }));
  dimList.sort((a, b) => b.score - a.score);

  const topDims = dimList.slice(0, 3);
  const bottomDims = dimList.slice(-3).reverse();

  const dimName = d => config.dimensions[d].name || d;

  // 优势/短板简短描述，从 dimComments 取前一句
  const short = txt => (txt || "").split(/。|！|!/)[0] + "。";

  let text = "";

  // 总体概述
  text += `整体来看，你当前的综合水平约为 NTRP ${roundedLevel}（${levelLabel}）。\n\n`;

  // 优势
  text += `你的主要优势在：\n`;
  for (const d of topDims) {
    text += `- ${dimName(d.dim)}（约 ${d.score.toFixed(1)} 级）：${short(dimComments[d.dim])}\n`;
  }
  text += `\n`;

  // 短板
  text += `当前最值得优先提升的环节是：\n`;
  for (const d of bottomDims) {
    text += `- ${dimName(d.dim)}（约 ${d.score.toFixed(1)} 级）：${short(dimComments[d.dim])}\n`;
  }
  text += `如果你只想抓重点，建议优先在上述 2～3 个方向投入练习时间。\n\n`;

  // 详细拆解
  text += `下面是各个维度的具体评估与建议：\n\n`;
  for (const d of dimList) {
    text += `【${dimName(d.dim)}（约 ${d.score.toFixed(1)} 级）】\n`;
    text += `${dimComments[d.dim] || ""}\n\n`;
  }

  return text.trim();
}
```

---

如果你愿意，下一步我可以：

* 直接基于你前面的 JSON 配置，把这三步（算分 → 选评语 → 拼 summary）整合成一个完整的 `evaluateNTRP()` JS 文件，
* 你只要在小程序里传入 `answers` 就能拿到全部结果（总等级 + 维度等级 + 完整长评语）。
